### -- Time Series Analysis -- ###
# Quarterly beer sales data. Use Holt-Winters seasonal method to capture seasonality and predict for next
# two years. Also use ARIMA model to predict next 2 years
# source here: https://rpubs.com/amitkayal/369361
# Load required libraries

install.packages("ggthemes")
install.packages("forecast")
install.packages("TSA")
install.packages("tseries")
install.packages("TeachingDemos")
library(ggthemes)
library(ggplot2)
library(scales)
library(forecast)
library(TSA)
library(tseries)
library(caret)
library(TeachingDemos)

# load the files for analysis and do EDA
beer_data <- read.csv('beer.csv')
str(beer_data)
nrow(beer_data)

# convert data into time serie design

# Time Series Analysis STEPS:
##1. Visualize the time series
##2. Stationarize the time series by extracting cycles and trends
##3. Plot ACF/PACF chart to find out optimal parameters
##4. Build ARIMA/Winter-Holls method
##5. Make the predictions

#. Visualize the time series
beer_timeseries <- ts(beer_data, frequency = 4, start = c(2002,1))
beer_timeseries
summary(beer_timeseries)
plot.ts(beer_timeseries, col='blue', main="Sales between 2002 - 2019")
# Data is plotted with time series with abline to understand if data has any pattern. abline is a linear-
# regression. Time series patterns are described in trend and seasonality
plot.ts(beer_timeseries, col='blue', main="Sales between 2002 - 2019")
abline(reg = lm(beer_timeseries ~ time(beer_timeseries)), col = 'red')
cycle(beer_timeseries)
Annual_beerSales = aggregate(beer_timeseries)
Annual_beerSales
plot.ts(Annual_beerSales, col='black', main = "Yearly Sales Product A")
boxplot(beer_timeseries ~ cycle(beer_timeseries))

# to detect seasonality (installed package TSA)
beer_p = periodogram(beer_data) # http://coolwiki.ipac.caltech.edu/index.php/What_is_a_periodogram%3F
freq_data <- beer_p$freq
spec_data <- beer_p$spec
beer_frequency_data <- data.frame(spec = spec_data, freq = freq_data)
beer_frequency_data[order(beer_frequency_data$spec, decreasing = TRUE),]

##2. Stationarize the Series
##the interaction between trend and seasonality are typically classified as either additive or multiplicative
## Additive time series: the component add together to make the time series
## Multiplicative time series: everything becomes more exaggerated.
decompose_beer_data <- decompose(beer_timeseries, type = 'additive')
seasonal_beer <- as.ts(decompose_beer_data$seasonal)
trend_beer <- as.ts(decompose_beer_data$trend)
random_beer <- as.ts(decompose_beer_data$random)
plot.ts(seasonal_beer, main = 'Seasonal Component') # plots shows a regular repeating pattern
plot.ts(trend_beer, main = 'Tend Component')
plot.ts(random_beer, main = 'Random Component')
plot.ts(beer_timeseries, main= 'Product Sales from 2002 to 2019')
plot(decompose(beer_timeseries, type = "additive"))
decompose_beer_data

##3. Adjusted Seasonality
# estimating the seasonal component, and substracting the seasonal component from the original ts.
# the seasonally adjusted ts only contains trend + noise
beer_ts_seasonallyadjusted <- beer_timeseries - seasonal_beer
plot.ts(beer_ts_seasonallyadjusted, main = "Seasonal Adjusted Plot of Sales Product")

##4. Build prediction model
beer_ts_hw <- hw(beer_timeseries, seasonal = 'additive', h=8)
beer_ts_hw$model # error term 318, residual that doesnt fit in our model (sigma parameter)
                 # s are seasonal parameter calculated for q1...q4

plot(beer_ts_hw$model)
plot(beer_ts_hw)
accuracy(beer_ts_hw)

# Analysis of the residuals
# to test the validity of the model we also examine the correlations between forecast error.
# if correlation exists in error terms, likely simple exponential smoothing forecasts could be improved
# by another technique. In acf plot not all the lines are within blue hashed line
plot(beer_ts_hw$residuals)
abline(0,0)
acf(beer_ts_hw$residuals)

##5. Prediction model
beer_ts_pred <- predict(beer_ts_hw, n.ahead=8, prediction.interval = TRUE)
beer_ts_pred$model
plot(beer_ts_pred$model)

beer_ts_pred_fc <- forecast(beer_ts_hw, h=8)
beer_ts_pred_fc$model

#compare prediction generated by predict and forecast method
par(mfrow=c(2,2))
plot.ts(beer_ts_pred, main = 'Forecasted sales by Predict Method', col = 'red')
plot.ts(beer_ts_pred_fc, main = 'Forecast Sales by Forecast Method', col = 'green')

# use ARIMA Model for prediction
kpss.test(beer_timeseries)
# p values is > 0.05 then failed to reject Ho. Accept Ho that ts is stationary
adf.test(beer_timeseries)
# p value is 0.01 < 0.05 then reject Ho and ts is not stationary

## Differenciation and other stuff wrt stational diff
beer_data_nsdiff <- nsdiffs(beer_timeseries)  # estimate the number of differences required to make a given time series stationaryestimates. the number of seasonal differences.
beer_data_differ <- diff(beer_timeseries, lag = frequency(beer_timeseries),differences = beer_data_nsdiff)
kpss.test(beer_data_differ)  ## checking if TS is stationary or not..look at p-value...here on difference data and p value <0.05 and so data is not stationary
plot.ts(beer_data_differ, col="blue", main = "After seasonal differencing")
abline(reg=lm(beer_data_differ~time(beer_data_differ)),col="red")

## Obtain optimal model ARIMA and parameters p, d, and q. Best model depends on AIC values
beerfit_m <- auto.arima(beer_timeseries,p=0, d=0, max.d =2, max.p=2, max.q= 2, max.P=2, max.Q=2, max.D=2, start.p =0, start.q=0, start.P=0, start.Q=0, stepwise=TRUE, trace=TRUE)
# select lowest AIC value

## Final Model and Residual value
beerfit_m_final <- arima(beer_timeseries, c(0,0,0),seasonal = list(order=c(0,1,1),period=12))
beerfit_m_final_forecast <- predict(beerfit_m_final, n.ahead = 8, prediction.interval = TRUE)
plot(residuals(beerfit_m_final))
abline(0,0)
acf(beerfit_m_final$residuals) # check residual
Box.test(beerfit_m_final$residuals, lag = 12, type = 'Ljung-Box')
